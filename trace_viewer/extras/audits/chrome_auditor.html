<!DOCTYPE html>
<!--
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<link rel="import" href="/base/base.html">
<link rel="import" href="/core/auditor.html">
<link rel="import" href="/extras/audits/chrome_audit.html">

<script>
'use strict';

/**
 * @fileoverview Base class for trace data Auditors.
 */
tv.exportTo('tv.e.audits', function() {
  var Auditor = tv.c.Auditor;

  /**
   * Auditor for Chrome-specific traces.
   * @constructor
   */
  function ChromeAuditor(model) {
    this.model = model;
    if (tv.e.audits.ChromeAudit.supportsModel(this.model))
      this.audit = new tv.e.audits.ChromeAudit(this.model);
    else
      this.audit = undefined;
  };

  ChromeAuditor.prototype = {
    __proto__: Auditor.prototype,

    runAudit: function() {
      if (!this.audit)
        return;

      var allFrameEvents = this.getAllFrameEvents();
      var allLatencyEvents = this.getAllLatencyEvents();

      var addIR = function(name, start, end) {
        start = (start / 300) * this.model.bounds.range;
        end = (end / 300) * this.model.bounds.range;
        start += this.model.bounds.min;
        end += this.model.bounds.min;

        this.model.addInteractionRecord(new tv.c.trace_model.InteractionRecord(
            name, tv.b.ui.getColorIdForReservedName(name),
            start, end - start));
      }.bind(this);
      addIR('mt_initial_load', 0, 100);
      addIR('mt_user_initiated_ui_state_change', 100, 116);
      addIR('mt_input_bound_effect', 116, 216);
      addIR('mt_generic_smooth_effect', 216, 247);
      addIR('mt_quiescence', 247, 300);
    },

    getAllFrameEvents: function() {
      var model = this.model;
      var frameEvents = [];
      if (this.audit.browser) {
        var fe = this.audit.browser.getFrameEventsInRange(
            tv.e.audits.IMPL_FRAMETIME_TYPE,
            model.bounds);
        frameEvents.push.apply(frameEvents, fe);
      }
      tv.b.iterItems(this.audit.renderers, function(pid, renderer) {
        var fe = renderer.getFrameEventsInRange(tv.e.audits.IMPL_FRAMETIME_TYPE,
                                       model.bounds);
        frameEvents.push.apply(frameEvents, fe);
      }, this);
      frameEvents.sort(function(x, y) { return x.start - y.start; });
      return frameEvents;
    },

    getAllLatencyEvents: function() {
      if (!this.audit.browser)
        return [];
      return this.audit.browser.getLatencyEventsInRange(this.model.bounds);
    }
  };

  Auditor.register(ChromeAuditor);

  return {
    ChromeAuditor: ChromeAuditor
  };
});
</script>
