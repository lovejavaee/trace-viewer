<!DOCTYPE html>
<!--
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<link rel="import" href="/base/base.html">
<link rel="import" href="/base/iteration_helpers.html">

<script>
'use strict';

/**
 * @fileoverview Utilities for accessing trace data about the Chrome browser.
 */
tv.exportTo('tv.e.audits', function() {
  var browserProcess_NAME = 'CrBrowserMain';
  var RENDERER_PROCESS_NAME = 'CrRendererMain';

  var UI_COMP_NAME = 'INPUT_EVENT_LATENCY_UI_COMPONENT';
  var ORIGINAL_COMP_NAME = 'INPUT_EVENT_LATENCY_ORIGINAL_COMPONENT';
  var BEGIN_COMP_NAME = 'INPUT_EVENT_LATENCY_BEGIN_RWH_COMPONENT';
  var END_COMP_NAME = 'INPUT_EVENT_LATENCY_TERMINATED_FRAME_SWAP_COMPONENT';

  var MAIN_RENDERING_STATS =
      'BenchmarkInstrumentation::MainThreadRenderingStats';
  var IMPL_RENDERING_STATS =
      'BenchmarkInstrumentation::ImplThreadRenderingStats';

  var MAIN_FRAMETIME_TYPE = 'main_frametime_type';
  var IMPL_FRAMETIME_TYPE = 'impl_frametime_type';

  function findChromeBrowserProcess(model) {
    var browsers = [];
    model.getAllProcesses().forEach(function(process) {
      if (process.findAllThreadsNamed(browserProcess_NAME).length !== 0)
        browsers.push(process);
    }, this);
    if (browsers.length === 0)
      return undefined;
    if (browsers.length > 1)
      return undefined;
    return browsers[0];
  }

  function findChromeRenderProcesses(model) {
    var rendererProcesses = [];
    model.getAllProcesses().forEach(function(process) {
      if (process.findAllThreadsNamed(RENDERER_PROCESS_NAME).length !== 0)
        rendererProcesses.push(process);
    });
    return rendererProcesses;
  }

  /**
   * @constructor
   */
  function ChromeAudit(model) {
    this.model_ = model;

    // Find browser.
    this.browserProcess_ = findChromeBrowserProcess(model);
    if (this.browserProcess_)
      this.browser_ = new ChromeBrowserAudit(this, this.browserProcess_);
    else
      this.browser_ = undefined;

    // Find renderers.
    this.rendererProcesses_ = findChromeRenderProcesses(model);

    this.renderers_ = {};
    this.rendererProcesses_.forEach(function(renderProcess) {
      var renderer = new ChromeRendererAudit(this, renderProcess);
      this.renderers_[renderer.pid] = renderer;
    }, this);
  }

  ChromeAudit.supportsModel = function(model) {
    if (findChromeBrowserProcess(model) !== undefined)
      return true;
    if (findChromeRenderProcesses(model).length)
      return true;
    return false;
  }

  ChromeAudit.prototype = {
    get pid() {
      throw new Error('woah');
    },

    get process() {
      throw new Error('woah');
    },

    get model() {
      return this.model_;
    },

    get browserProcess() {
      return this.browserProcess_;
    },

    get browser() {
      return this.browser_;
    },

    get rendererProcesses() {
      return this.rendererProcesses_;
    },

    get renderers() {
      return this.renderers_;
    }
  };

  function ChromeProcessAudit(audit, process) {
    this.audit = audit;
    this.process = process;
  }

  ChromeProcessAudit.prototype = {
    get pid() {
      return this.process.pid;
    },

    getFrameEventsInRange: function(frametimeType, range) {
      var titleToGet;
      if (frametimeType == MAIN_FRAMETIME_TYPE)
        titleToGet = MAIN_RENDERING_STATS;
      else
        titleToGet = IMPL_RENDERING_STATS;

      var frameEvents = [];
      this.process.iterateAllEvents(function(event) {
        if (event.title !== titleToGet)
          return;
        if (range.intersectsExplicitRange(event.start, event.end))
          frameEvents.push(event);

      });

      frameEvents.sort(function(a, b) {return a.start - b.start});
      return frameEvents;
    }
  };

  function ChromeRendererAudit(audit, process) {
    ChromeProcessAudit.call(this, audit, process);
  }

  ChromeRendererAudit.prototype = {
    __proto__: ChromeProcessAudit.prototype
  };

  function ChromeBrowserAudit(audit, process) {
    ChromeProcessAudit.call(this, audit, process);
  }

  ChromeBrowserAudit.prototype = {
    __proto__: ChromeProcessAudit.prototype,

    get hasLatencyEvents() {
      var hasLatency = false;
      this.audit.model.getAllThreads().forEach(function(thread) {
        thread.iterateAllEvents(function(event) {
          if (event.title.indexOf('InputLatency') === 0)
            hasLatency = true;
        });
      });
      return hasLatency;
    },

    getLatencyEventsInRange: function(rangeOfInterest) {
      var latencyEvents = [];
      this.audit.model.getAllThreads().forEach(function(thread) {
        thread.iterateAllEvents(function(event) {
          if (event.title.indexOf('InputLatency') === 0) {
            latencyEvents.push(event);
          }
        });
      });

      return getSlicesIntersectingRange(rangeOfInterest,
                                        latencyEvents);
    },

    getLatencyDataInRange: function(rangeOfInterest) {
      var latencyEvents = this.getLatencyEventsInRange(rangeOfInterest);

      // Helper function that computes the input latency for one async slice.
      function maybeEventToLatencyDatum(event) {
        if (!('data' in event.args))
          return;

        var data = event.args.data;
        if (!(END_COMP_NAME in data))
          return;

        var latency = 0;
        var endTime = data[END_COMP_NAME].time;
        if (ORIGINAL_COMP_NAME in data) {
          latency = endTime - data[ORIGINAL_COMP_NAME].time;
        } else if (UI_COMP_NAME in data) {
          latency = endTime - data[UI_COMP_NAME].time;
        } else if (BEGIN_COMP_NAME in data) {
          latency = endTime - data[BEGIN_COMP_NAME].time;
        } else {
          throw new Error('No valid begin latency component');
        }
        return {
          'x': event.start,
          'latency': latency / 1000.0
        };
      };

      var latencyData = [];
      latencyEvents.forEach(function(event) {
        var latencyDatum = maybeEventToLatencyDatum(event);
        if (latencyDatum)
          latencyData.push(latencyDatum);
      });
      latencyData.sort(function(a, b) {return a.x - b.x});
      return latencyData;
    }
  };

  function getSlicesIntersectingRange(rangeOfInterest, slices) {
    var slicesInFilterRange = [];
    for (var i = 0; i < slices.length; i++) {
      var slice = slices[i];
      if (rangeOfInterest.intersectsExplicitRange(slice.start, slice.end))
        slicesInFilterRange.push(slice);
    }
    return slicesInFilterRange;
  }


  function getFrametimeDataFromEvents(frameEvents) {
    var frametimeData = [];
    for (var i = 1; i < frameEvents.length; i++) {
      var diff = frameEvents[i].start - frameEvents[i - 1].start;
      frametimeData.push({
        'x': frameEvents[i].start,
        'frametime': diff
      });
    }
    return frametimeData;
  }

  return {
    ChromeAudit: ChromeAudit,

    MAIN_FRAMETIME_TYPE: MAIN_FRAMETIME_TYPE,
    IMPL_FRAMETIME_TYPE: IMPL_FRAMETIME_TYPE,

    getSlicesIntersectingRange: getSlicesIntersectingRange,
    getFrametimeDataFromEvents: getFrametimeDataFromEvents
  };
});
</script>
